Для хранения упорядоченных коллекций существует особая структура данных - массив (Array).

Способы создания массива:

let arr = new Array();
let arr = [];

(Обычно используется второй)

let fruits = ["apple", "orange", "lemon"];

arr[n] - доступ к элементу n

В одном массиве могут находится элементы разных типов

Размер массива можно получить через атрибут length

arr.length

Методы массивов:

pop() - возвращает последний и удаляет его из массива
push(n) - добавляет в конец
shift() - возвращает  первый и удаляет его
unshift(n) - добавляет в начало

push и unshift могут добавлять сразу несколько элементов

fruits.push("tomato", "potato");

Перебор элементов можно осуществлять с помощью специального цикла for (foreach)

for (let fruit of fruits) {
	...
}

Могут использоваться отрицательные индексы - будут браться элементы с конца

arr[n - 1] = arr[-1]

Многомерные массивы

let matrix = [
	[1, 2, 3],
	[4, 5, 6]
];

Для получения можно использовать метод .at(n)

Для удаления используется метод splice. Удаляет deleteCount (все если не указан) элементов, начиная
с индекса index, и вставляет на их место элементы added1, added2...

arr.splice(index,  [deleteCount], [added1], [added2], ...);

Также для удаления может использоваться метод slice

arr.slice([start], [end]);

slice создаёт копию, не изменяя самого массива, поэтому его иногда используют, чтобы создать копию массива

Метод concat создаёт копию и добавляет в него элементы

arr.concat(elem1, elem2, ...);

Есть метод forEach, в который передаётся анонимная функция

arr.forEach(function(item, index, array) {
	// do something with item
});

Поиск в массиве

indexOf(item, [from]) - ищет item начииная с индекса from, возвращает первый найденный
lastIndexOf(item, [from]) - ищет item начииная с индекса from, возвращает последний найденный
includes(item, [from]) - ищет item начииная с индекса from, возвращает true если найдено, иначе - false

Метод find принимает анонимную функцию. Если она возвращает true - возвращается элемент.
Если ни одна true не вернула - undefined

let result = arr.find(function(item, index, array) {
	// check item
});

Метод filter в отличие от find возвращает не один подходящий объект, а массив всех подошедших

let result = arr.filter(function(item, index, array) {
	// check item
});

Метод map вызывает функцию для каждого элемента и возвращает массив результатов выполнения этой функции

let lengths = ["a", "bc", "def"].map(item => item.length);
alert(lengths);	// 1 2 3

Для сортировки используется метод sort, в который может быть передан компаратор

function backward(a, b) {
	if (a < b)
		return 1;
	if (a == b)
		return 0;
	return -1;
}

arr.sort();
arr.sort(backward);

Метод reverse разворачивает массив

arr.reverse()

Метод строк split(del) разбивает строку на массив подстрок, по разделителю del (по умолчанию - пробел).

let names = "Маша;Паша;Игорь".split(";");

Метод join(glue) - наоборот, из массива делает строку, вставляя между элементами glue

let names = ["Маша","Паша","Игорь"].join(";");

Метод isArray() возвращает, является ли массив объектом



Бывает удобно распаковывать объекты/массивы в несколько переменных. Это называется деструктуризация

let arr = ["Igor", "Zholobov"];
let [firstname, surname] = arr;

Деструктаризация не изменяет объект/массив в правой части

Ненужные элементы можно пропускать, ставя лишнюю запятую

let arr = ["Igor", "Vadimovic", "Zholobov"];
let [firstname, , surname] = arr;

С помощью деструктурирующего присваивания можно обменять значения двух переменных

let user = "Igor";
let admin = "Pavel";
[user, admin] = [admin, user];

С объектами

let options = {
	title: "Menu",
	width: 100,
	height: 200
};

let {width: w, height: h, title} = options;
Вид: { source: target }

Можно делать более сложные конструкции

let options = {
	title: "Menu";
	size: {
		width: 100,
		height: 200
	}
};

let {
	size: {
		width,
		height
	},
	title
} = options;



Рекурсивная функция

... ну тут понятно чё это

Информация о процессе выполнения функции хранится в её контексте выполнения

Это специальная структура данных, включающая в себя кокнретное место в коде, на котором
находится интерпретатор, локальные переменные функции, значение this и прочее.

Когда функция производит вложенный вызов:
1. её выполнение приостанавливается
2. контекст выполнения, связаный с ней, запоминается в стеке контекстов выполнения
3. выполняются вложенные вызовы, для каждого из которых создаётся свой контекст
4. после завершения старый контекст достаётся из стека и выполнение внешней продолжается с того момента
где она была закончена



Связный список

Связный список опреледяется рекурсивно как объект, имеющий поля value и ext

let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };



Глобальный объект

Глобальный объект представляет переменные и функции, доступные в любом месте программы.
В браузере он называется window

var gVar = 5;
alert(window.gVar);



